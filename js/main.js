// Generated by CoffeeScript 1.4.0
(function() {
  var DrawingCanvas, Food, Game, MainSnake, MirrorSnake, areAtSamePlace, distance, equiprobable, intersect, nextColor, randomPosition, _currentColor,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  $(function() {
    return new Game;
  });

  _currentColor = -1;

  nextColor = function() {
    var colors;
    colors = ['#bc2424', '#2abc24', '#2461bc', '#6c24bc', '#b6bc24', '#24bca3', '#0e2ba6', '#a60e93'];
    _currentColor = (_currentColor + 1) % colors.length;
    return colors[_currentColor];
  };

  equiprobable = function(min, max) {
    return Math.floor(Math.random() * (1 + max - min)) + min;
  };

  distance = function(onePosition, anotherPosition) {
    var xDiff, yDiff;
    xDiff = onePosition.x - anotherPosition.x;
    yDiff = onePosition.y - anotherPosition.y;
    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
  };

  randomPosition = function(gridWidth, gridHeight) {
    return {
      x: equiprobable(0, gridWidth),
      y: equiprobable(0, gridHeight)
    };
  };

  areAtSamePlace = function(oneThing, otherThing) {
    return oneThing.position.x === otherThing.position.x && oneThing.position.y === otherThing.position.y;
  };

  intersect = function(oneList, anotherList) {
    var anotherElement, element, _i, _j, _len, _len1;
    for (_i = 0, _len = oneList.length; _i < _len; _i++) {
      element = oneList[_i];
      for (_j = 0, _len1 = anotherList.length; _j < _len1; _j++) {
        anotherElement = anotherList[_j];
        if (element.x === anotherElement.x && element.y === anotherElement.y) {
          return true;
        }
      }
    }
    return false;
  };

  MainSnake = (function() {

    MainSnake.prototype.length = 6;

    function MainSnake() {
      this.color = '#ededed';
      this.direction = 'right';
      this.drawingCanvas = new DrawingCanvas($('canvas'));
      this.position = {
        x: Math.round(this.drawingCanvas.gridWidth / 2),
        y: Math.round(this.drawingCanvas.gridHeight / 2)
      };
      this.history = [
        {
          x: this.position.x,
          y: this.position.y
        }
      ];
    }

    MainSnake.prototype.move = function() {
      if (this.direction === 'right') {
        this.position.x += 1;
      } else if (this.direction === 'left') {
        this.position.x -= 1;
      } else if (this.direction === 'up') {
        this.position.y -= 1;
      } else {
        this.position.y += 1;
      }
      this.position.x = this.drawingCanvas.normalizeWidth(this.position.x);
      this.position.y = this.drawingCanvas.normalizeHeight(this.position.y);
      return this.history.push({
        x: this.position.x,
        y: this.position.y
      });
    };

    MainSnake.prototype.render = function() {
      var i, _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 6; i = ++_i) {
        if (this.history.length - i > -1) {
          _results.push(this.drawingCanvas.drawSquare(this.history[this.history.length - i].x, this.history[this.history.length - i].y, this.color));
        } else {
          _results.push(this.drawingCanvas.drawSquare(this.history[0].x + this.history.length - i, this.history[0].y, this.color));
        }
      }
      return _results;
    };

    MainSnake.prototype.occupiedSpace = function() {
      return this.history.slice(this.history.length - 6, this.history.length);
    };

    MainSnake.prototype.keyPressed = function(keyCode) {
      if (keyCode === 37 && this.direction !== 'right') {
        return this.direction = 'left';
      } else if (keyCode === 38 && this.direction !== 'down') {
        return this.direction = 'up';
      } else if (keyCode === 39 && this.direction !== 'left') {
        return this.direction = 'right';
      } else if (keyCode === 40 && this.direction !== 'up') {
        return this.direction = 'down';
      }
    };

    return MainSnake;

  })();

  MirrorSnake = (function() {

    MirrorSnake.prototype.length = 6;

    function MirrorSnake(params) {
      this.params = params;
      this.color = this.params.color;
      this.originalSnake = this.params.of;
      this.offset = 0;
      this.drawingCanvas = new DrawingCanvas($('canvas'));
    }

    MirrorSnake.prototype.move = function() {
      return this.offset += 1;
    };

    MirrorSnake.prototype.render = function() {
      var i, position, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        position = this.originalSnake.history[this.offset + i];
        _results.push(this.drawingCanvas.drawSquare(position.x, position.y, this.color));
      }
      return _results;
    };

    MirrorSnake.prototype.occupiedSpace = function() {
      return this.originalSnake.history.slice(this.offset, this.offset + this.length);
    };

    return MirrorSnake;

  })();

  Food = (function() {

    function Food() {
      this.color = nextColor();
      this.drawingCanvas = new DrawingCanvas($('canvas'));
      this.position = randomPosition(this.drawingCanvas.gridWidth, this.drawingCanvas.gridHeight);
    }

    Food.prototype.render = function() {
      this.position.x = this.drawingCanvas.normalizeWidth(this.position.x);
      this.position.y = this.drawingCanvas.normalizeHeight(this.position.y);
      return this.drawingCanvas.drawSquare(this.position.x, this.position.y, this.color);
    };

    Food.prototype.regenerateDependingOn = function(snakePosition) {
      while (this.distanceToCenter() < 10 || this.distanceToSnake(snakePosition) < 10) {
        this.position = randomPosition(this.drawingCanvas.gridWidth, this.drawingCanvas.gridHeight);
      }
      return this.color = nextColor();
    };

    Food.prototype.distanceToCenter = function() {
      return distance(this.position, {
        x: this.drawingCanvas.gridWidth / 2,
        y: this.drawingCanvas.gridHeight / 2
      });
    };

    Food.prototype.distanceToSnake = function(snakePosition) {
      return distance(this.position, snakePosition);
    };

    return Food;

  })();

  Game = (function() {

    function Game() {
      this.mainLoop = __bind(this.mainLoop, this);
      this.mainSnake = new MainSnake;
      this.mirrorSnakes = [];
      this.food = new Food;
      this.gameState = 'paused';
      this.score = 0;
      this.initCanvas();
      this.bindEvents();
      this.frameRate = 20;
      setInterval(this.mainLoop, 1000 / this.frameRate);
    }

    Game.prototype.initCanvas = function() {
      this.gridWidth = 100;
      this.gridHeight = 50;
      return this.drawingCanvas = new DrawingCanvas($('canvas'));
    };

    Game.prototype.bindEvents = function() {
      var _this = this;
      return $(window).on('keydown', function(e) {
        if (e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
          _this.gameState = 'playing';
          return _this.mainSnake.keyPressed(e.keyCode);
        }
      });
    };

    Game.prototype.addScore = function() {
      this.score += 1;
      return $('#score-number').text(this.score);
    };

    Game.prototype.resetScore = function() {
      this.score = 0;
      return $('#score-number').text(this.score);
    };

    Game.prototype.mainLoop = function() {
      var _i, _len, _ref;
      if (this.gameState === 'playing') {
        this.drawingCanvas.clear();
        this.mainSnake.move();
        if (areAtSamePlace(this.mainSnake, this.food)) {
          this.mirrorSnakes.push(new MirrorSnake({
            of: this.mainSnake,
            color: this.food.color
          }));
          this.food.regenerateDependingOn(this.mainSnake.position);
          this.addScore();
        }
        _ref = this.mirrorSnakes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          this.snake = _ref[_i];
          this.snake.move();
          this.snake.render();
          if (this.collision(this.mainSnake, this.snake)) {
            this.gameState = 'over';
          }
        }
      }
      this.food.render();
      return this.mainSnake.render();
    };

    Game.prototype.showGameOver = function() {
      return $('#game-over').show();
    };

    Game.prototype.hideGameOver = function() {
      return $('#game-over').hide();
    };

    Game.prototype.collision = function(oneSnake, anotherSnake) {
      return intersect(oneSnake.occupiedSpace(), anotherSnake.occupiedSpace());
    };

    return Game;

  })();

  DrawingCanvas = (function() {

    function DrawingCanvas($el) {
      this.$el = $el;
      this.setSizes = __bind(this.setSizes, this);

      this.el = this.$el[0];
      $(window).resize(this.setSizes);
      this.setSizes();
      this.ctx = this.el.getContext('2d');
    }

    DrawingCanvas.prototype.setSizes = function() {
      this.el.width = this.$el.width();
      this.el.height = this.$el.height();
      this.minGridSize = 50;
      if (this.el.height < this.el.width) {
        this.gridHeight = this.minGridSize;
        this.gridWidth = Math.round(this.minGridSize * this.el.width / this.el.height);
      } else {
        this.gridHeight = Math.round(this.minGridSize * this.el.height / this.el.width);
        this.gridWidth = this.minGridSize;
      }
      return console.log(this.el.width, this.el.height);
    };

    DrawingCanvas.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.el.width, this.el.height);
    };

    DrawingCanvas.prototype.drawSquare = function(x, y, color) {
      this.ctx.fillStyle = color;
      x = this.normalizeWidth(x);
      y = this.normalizeHeight(y);
      return this.ctx.fillRect(x * this.el.width / this.gridWidth, y * this.el.height / this.gridHeight, this.el.width / this.gridWidth, this.el.height / this.gridHeight);
    };

    DrawingCanvas.prototype.normalizeWidth = function(x) {
      return this.normalize(x, this.gridWidth);
    };

    DrawingCanvas.prototype.normalizeHeight = function(y) {
      return this.normalize(y, this.gridHeight);
    };

    DrawingCanvas.prototype.normalize = function(n, mod) {
      while (n < 0) {
        n += mod;
      }
      while (n >= mod) {
        n -= mod;
      }
      return n;
    };

    return DrawingCanvas;

  })();

}).call(this);
